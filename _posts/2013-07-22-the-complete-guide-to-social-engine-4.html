---
layout: post
title: 'The Complete Guide to Social Engine 4 Module Development Part 7: Forms and
  Form Elements'
date: '2013-07-22T23:41:00.000-07:00'
author: Marco Enrico
tags:
- socialengine
- customization
- SE PHP
- development
- form
- se4
- social engine
modified_time: '2013-07-23T20:19:32.594-07:00'
blogger_id: tag:blogger.com,1999:blog-8533127149230967660.post-8823548051615685649
blogger_orig_url: http://social-engine-tutorials.blogspot.com/2013/07/the-complete-guide-to-social-engine-4.html
---

<h2>SE4 Forms </h2>I initially intended to make a post about tasks and jobs as part 7 of this series. After working on a number of projects in the months that passed I realized that I forgot to discuss the most common task in SE4&nbsp; (it's called SE PHP now but I'll still refer to it as SE4 if you don't mind) customization which is customizing forms and creating forms.<br /><br />In SE4 there are "standard forms" and "custom fields form". Take for example when in the sign up process, assuming the default order that comes with SE4 out of the box, you are first greeted with a form entitled "Create Account". This form is an instance of <code>User_Form_Signup_Account</code> which is an instance of Engine_Form. This is the most&nbsp; most common form you'll encounter in SE4 and the subject of this post. The next form in the sign up process asks for your profile details. This is an instance of <code>User_Form_Signup_Fields</code>. Among other things, the elements of this type of form can be customized via the admin panel. These types of form extends <code>Fields_Form_Standard</code>. Most 3rd party modules have this type of form to provide a way for site admins to customize the information to be asked from users pertaining to a particular <a href="{{ site.baseurl }}{% post_url 2012-07-14-complete-guide-to-social-engine-4_14 %}" target="_blank">item</a>. This is a complex and interesting subject matter which is best discused in another post.<br /><br /><h2>Creating Forms</h2>In a module, scripts providing class definitions for forms are located in <code>application/modules/&lt;Modulename&gt;/Form</code>. In our Car module example we need a creation form.&nbsp; So we create the file <code>application/modules/Car/Form/Create.php</code> and it it we put:<br /><br /><script class="brush:php" type="syntaxhighlighter"><![CDATA[  <?php  class Car_Form_Create extends Engine_Form {   public function init()   {   } }     ]]></script> The <code>Engine_Form</code> class supports setDescription and setTitle to set the description and title of the form respectively. You can consult the documentation for <a href="http://framework.zend.com/manual/1.12/en/zend.form.html" rel="nofollow" target="_blank"><code>Zend_Form</code></a> for a complete list of supported methods.<br /><br />&nbsp;In the body of <code>init()</code> is where we define the elements of the form. The easiest way to add an element is via this snippet:<br /><br /><script class="brush: html" type="syntaxhighlighter"><![CDATA[     $this->addElement('<elementtype>', '<name>', array(/* options */)); ]]></script> Out of the box SE4 (4.5.0) supports the following types:<br /><ul><li>Birthdate - renders as 3 select fields for month, day and year. Extends the Date element and includes validation of birthdates i.e inclusion of month/date.</li><li>Button -&nbsp; standard button form field.</li><li>CalendarDateTime - calendar date picker</li><li>Cancel - a form button by default. Can be rendered as a link by setting the option "link".</li><li>Captcha - renders a captcha. Requires some configuration.</li><li>Checkbox - a standard checkbox.</li><li>Date - renders as 3 select fields for month, day and year</li><li>Dummy </li><li>Duration</li><li>Exception</li><li>FancyUpload</li><li>File</li><li>Float</li><li>Hash</li><li>Heading</li><li>Hidden</li><li>Image</li><li>Integer</li><li>MultiCheckbox</li><li>Multiselect</li><li>MultiText</li><li>Password</li><li>Radio</li><li>Reset</li><li>Select</li><li>SingleRadio</li><li>SubForm</li><li>Submit</li><li>Text</li><li>Textarea</li><li>TinyMce</li></ul><br />To specify an element type you may use lower case letters but be careful with multi word names. For example, "<code>multiselect</code>" works as well as "<code>Multiselect</code>" but not "<code>multiSelect</code>". In addition, "<code>TinyMce</code>" and "<code>tinyMce</code>" works but not "<code>tinymce</code>".<br /><br />The name of the element is required. The name will be the id and name attribute of the rendred form element on the page. These can be overridden by using the element's setAttrib method.<br /><br />By extending Engine_Form form classes gets the default decorators and thus the same stying as default SE4 forms.<br /><br />The options parameter sets the attributes of the element or it's options. HTML attributes may be specified as key/value pairs in the options parameter array as in the following example:<br /><br /><script class="brush:php" type="syntaxhighlighter"><![CDATA[ <?php  class Car_Form_Create extends Engine_Form {   public function init()   {     $this->setTitle('Post a Car');     $this->setDescription('Please set the details of your car post below.');     $this->addElement('text', 'title', array(       // The label of the element rendered as a label tag wrapped       // in div with id <elementname>-label       'label' => 'Title',       // Descriptions are rendered above the form element by default.       'description' => '<em>Ex. "My First Car"</em>',       'required' => true,       'filters' => array(         new Engine_Filter_Censor(),         'StripTags'       )     ));     $this->title->getDecorator('description')->setEscape(false);      $this->addElement('textarea', 'description', array(       'label' => 'Description',       'filters' => array(         new Engine_Filter_Censor(),         'StripTags'       )     ));      $this->addElement('text', 'tags', array(       'label' => 'Tags',       'autocomplete' => 'off',       'filters' => array(         new Engine_Filter_Censor(),       )     ));      $this->addElement(new Car_Form_Element_Color('color', array(       'label' => 'Color',       'cellWidth' => 12,       'cellHeight' => 16,       'validators' => array(         array('Regex', true, array('pattern' => '/^#[a-f0-9]{6}$/i',         'messages' => 'Invalid color.'))       )     )));      // Another way of doing the code above by adding a prefix path.     // This is convinient should you be using a lot of custom form elements     //$this->addPrefixPath('Car_Form_Element', APPLICATION_PATH .     //'/application/modules/Car/Form/Element', 'element');     //$this->addElement('color', 'color', array(     //  'label' => 'Color',     //  'validators' => array(     //    array('Regex', true, array('pattern' => '/^#[a-f0-9]{6}$/i',     //    'messages' => 'Invalid color.'))     //  )     //));      // Using a regular     $this->addElement('button', 'submit', array(       'type' => 'reset',       'decorators' => array('ViewHelper'),       'label' => 'Create',       'ignore' => true     ));      $this->addElement('cancel', 'cancel', array(       'link' => true,       'decorators' => array('ViewHelper'),       'label' => 'Cancel',       'prependText' => ' or '     ));      $this->addDisplayGroup(array('submit', 'cancel'), 'buttons');   } }     ]]></script>The most commonly used options are <code>label</code>, <code>description</code>, and <code>required</code>. <code>Label</code> is the label of the element. Any html code in the value of <code>label</code> are escaped. Unlike <code>label</code>, <code>description</code> can render html code. This is done by setting escaping to false as shown in the example above.<br /><br />For select, <code>Multiselect</code>, <code>MultiCheckbox</code>, and <code>radio</code> the option <code>multiOptions</code> is used to set the options of the element. This can be an numerically indexed array or an associative array. The keys/indexes will be used as the value of the option elements and the values will be used as the label of the option elements. These elements includes the InArray validator by default. If you dynamically load the options via javascript this can be problematic. To disable it use the option <code>registerInArrayValidator</code> to false.<br /><br />For <code>button</code>, <code>cancel</code>, <code>reset</code>, <code>cancel</code> and <code>submit</code> the label is used as the label of the button and the label decorator is disabled. For buttons to be grouped and styled properly a display group is used in addition to overriding the default decorators. Please note that although <code>reset</code> and <code>submit</code> are available they are instances of <code>Zend_Form_Element_Submit</code> and <code>Zend_Form_Element_Reset</code> respectively and thus are not styled properly. You may use <code>button</code> for this and set type to "submit" or "reset" to emulate the function.  The <code>cancel</code> element is a custom SE4 form element is used very often. By default it is a button which has an onclick attribute which sends the browser back to the previous page. Setting "link" to true will render an anchor tag. As an anchor you may use the "href" option to send the browser to the specified location. The "prependText" is the text prepended to the element (often " or ").<br /><br />The "decorator", "validators" and "filters" options are discussed in the <a href="http://framework.zend.com/manual/1.10/en/zend.form.standardElements.html" rel="nofollow" target="_blank">zend manual</a>. <br /><br /><h2>Creating Custom Elements</h2>In the example above we added the custom element <code>color</code>. The example also shows two ways to specify elements to be added to the form. Here is the class declaration of our color element located in <code>application/modules/Car/Form/Element/Color.php</code>:<br /><script class="brush:php" type="syntaxhighlighter"><![CDATA[ <?php  class Car_Form_Element_Color extends Engine_Form_Element_Text {   public $helper = 'formColor'; }  ]]></script><br />The view helper <code>FormColor</code> does the most of the magic here. Here is the code located in <code>application/modules/Car/View/Helper/FormColor.php</code> :<br /><script class="brush:php" type="syntaxhighlighter"><![CDATA[ <?php  class Car_View_Helper_FormColor extends Zend_View_Helper_FormElement {    public function formColor($name, $value = null, $attribs = null,       $options = null, $listsep = "<br />\n")   {     $info = $this->_getInfo($name, $value, $attribs, $options, $listsep);     extract($info); // name, value, attribs, options, listsep, disable     $cellWidth = empty($attribs['cellWidth']) ? 8 : $attribs['cellWidth'];     unset($attribs['cellWidth']);     $cellHeight = empty($attribs['cellHeight']) ? 12 : $attribs['cellHeight'];     unset($attribs['cellHeight']);     $this->view->headScript()->appendFile($this->view->layout()->staticBaseUrl       . 'application/modules/Car/externals/scripts/color-picker.js');     return $this->view->formText($name, $value, $attribs, $options)       . $this->view->inlineScript()->appendScript(         sprintf("new ColorPicker($('%s'), {cellWidth: %d, cellHeight: %d})",           $name, $cellWidth, $cellHeight));   } }     ]]></script><br />Most of the time creating a custom form elements involves just changing how it is rendered via a view helper which is specified by the <code>$helper</code> property of the element. In this example render a text element in addition to some inline javascript code to create the color picker. Additional styles would be needed for the color picker to display properly.<br />View helpers can be a subject of a another post. But for now it should be noted that for our <code>FormColor</code> view helper to be available to the framework, the following code must be added to the bootstrap file application/modules/Car/Bootstrap.php: <script class="brush:php" type="syntaxhighlighter"><![CDATA[ <?php  class Car_Bootstrap extends Engine_Application_Bootstrap_Abstract {   public function __construct($application)   {     parent::__construct($application);     $this->initViewHelperPath();   }  }  ]]></script><br /><h2>Using Forms</h2>In a controller action the form should be instantiated and assigned to to view. To populate a form with values use the <code>populate</code> method. Submitted form values are validated via the <code>isValid</code>. This method has the effect of populating the form with filtered values and setting error messages for the form or form elements if any. Use the <code>getValues</code> method to get the filtered values from the form after a successful validation.<br /><br /><h2>Rendering Forms</h2><br />The following is the content of the view script for the create action for the index controller of the Car module: <script class="brush:php" type="syntaxhighlighter"><![CDATA[ <?php echo $this->partial('_tagsCommonJS.tpl', 'car') ?><?php echo $this->form->render($this); ]]></script><br />The partial contains javascript code to control the tags field's auto suggest feature. It will be used on both the create and edit routines of the car module and will probably be used in other view scripts for albums, videos etc so it's logical to put it on a separate script for easy reuse. The following shows it's content:<br /><script class="brush:php" type="syntaxhighlighter"><![CDATA[ <?php   $this->headScript()     ->appendFile($this->layout()->staticBaseUrl . 'externals/autocompleter/Observer.js')     ->appendFile($this->layout()->staticBaseUrl . 'externals/autocompleter/Autocompleter.js')     ->appendFile($this->layout()->staticBaseUrl . 'externals/autocompleter/Autocompleter.Local.js')     ->appendFile($this->layout()->staticBaseUrl . 'externals/autocompleter/Autocompleter.Request.js'); ?> &lt;script type="text/javascript"&gt;   en4.core.runonce.add(function()   {     new Autocompleter.Request.JSON('tags', '<?php echo $this->url(array('controller' => 'tag', 'action' => 'suggest'), 'default', true) ?>', {       'postVar' : 'text',       'customChoices' : true,       'minLength': 1,       'selectMode': 'pick',       'autocompleteType': 'tag',       'className': 'tag-autosuggest',       'filterSubset' : true,       'multiple' : true,       'injectChoice': function(token){         var choice = new Element('li', {'class': 'autocompleter-choices', 'value':token.label, 'id':token.id});         new Element('div', {'html': this.markQueryValue(token.label),'class': 'autocompleter-choice'}).inject(choice);         choice.inputValue = token;         this.addChoiceEvents(choice).inject(this.choices);         choice.store('autocompleteChoice', token);       }     });   }); &lt;/script&gt; ]]></script><br /><h2>Advanced Stuff</h2>You probably read this post wanting to learn how to do stuff like <a href="http://devzone.zend.com/1240/decorators-with-zend_form/" rel="nofollow" target="_blank">customizing the layout of form</a>, <a href="http://framework.zend.com/manual/1.12/en/zend.form.forms.html#zend.form.forms.subforms" rel="nofollow" target="_blank">adding sub-forms</a> or <a href="http://framework.zend.com/manual/1.12/en/zend.form.advanced.html#zend.form.advanced.multiPage" rel="nofollow" target="_blank">creating multi page forms</a>. Unfortunately these are lengthy topics and are discussed else where on the web. Ask Mr. Google and build upon the stuff you just read and you'll be on your way.<br /><br />This completes Part 7 of our series. Up next are custom profile fields.